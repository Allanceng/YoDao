{
  "name": "Yodao",
  "tagline": "YoDao Is A Simple and Fast ORM library for android.",
  "body": "# YoDao框架说明\r\n\r\n[TOC]\r\n\r\n## 简要说明\r\n\r\nYoDao是一个简单又高效的Android ORM开源框架。\r\n\r\n项目主页：https://github.com/sandin/YoDao\r\n\r\n项目作者：[sandin](mailto:lds2012@gmail.com)\r\n\r\n### 1.实现目标\r\n\r\n项目受Hibernate等ORM框架启发，并实现了Java Persistence API标准，在大部分系统设计上学习了[Spring Data JPA](http://docs.spring.io/spring-data/jpa/docs/current/reference/html/)框架，所以在使用和其API上十分相似。\r\n\r\n本项目和GreenDao，OrmLite等传统ORM框架不同的是，为了提高性能所以没有使用运行时的反射来解析注解，而使用[dagger](https://github.com/square/dagger)和[butterknife](https://github.com/JakeWharton/butterknife)一样的技术在编译时解析注解并自动生成代码，因此在使用ORM来提高开发效率的同时也没有牺牲运行时的性能和速度。\r\n\r\n因此框架的目标是实现一个快速而轻量的ORM框架，即可以提高开发效率，但又不牺牲运行时的性能。\r\n\r\n### 2.框架结构\r\n\r\n整个框架和butterknife一样，分为三个子项目：\r\n\r\n1. 主项目，这是一个Android library项目，在使用的时候引用即可。\r\n2. 编译项目，这是一个编译工具，在IDE或gradle里配置即可，无需打包到APK里。\r\n3. 实例项目，DEMO演示。\r\n\r\n### 3.加入项目\r\n\r\n此项目为开源项目，因此欢迎任何有着开源精神的开发者参与进来，有意者可以联系作者，或直接在github上[fork](https://github.com/sandin/YoDao)该项目。\r\n\r\n\r\n\r\n## 使用说明\r\n\r\n基本使用是和dagger一样，这里仅描述android studio的使用方式：\r\n\r\n### 1. 修改gradle配置\r\n\r\n在 `build.gradle` 文件加入一下配置：\r\n\r\n``` groovy\r\napply plugin: 'com.neenbedankt.android-apt'\r\n\r\n// ...\r\n\r\nbuildscript {\r\n\tdependencies {\r\n    \tclasspath 'com.neenbedankt.gradle.plugins:android-apt:1.8'\r\n\t}\r\n}\r\n\r\nrepositories {\r\n    jcenter()\r\n}\r\n\r\ndependencies {\r\n    compile 'com.lds:yodao:0.2.1'\r\n    apt 'com.lds:yodao-compiler:0.2.1'\r\n}\r\n```\r\n\r\n注意：目前仅上传到[jcenter](https://bintray.com/bintray/jcenter)，还没有同步到Maven Center。\r\n\r\n### 2. JavaBean增加注解\r\n\r\n``` Java\r\nimport com.yoda.yodao.annotation.Column;\r\nimport com.yoda.yodao.annotation.GeneratedValue;\r\nimport com.yoda.yodao.annotation.GenerationType;\r\nimport com.yoda.yodao.annotation.Id;\r\n\r\n@Entity\r\n@Table(name=\"user\")\r\npublic class User implements Serializable {\r\n\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.AUTO)\r\n    private long id;\r\n\r\n    @Column\r\n    private String name;\r\n\r\n    @Column(name = \"age\")\r\n    private int age;\r\n\r\n    public User() {\r\n    }\r\n\r\n  \t// Getter & Setter\r\n    // ...\r\n}\r\n```\r\n\r\n这里使用的注解和JPA一模一样，只是因为android里面没有 `javax.persistence `包，所以所有的注解都放置在 `com.yoda.yodao.annotation` 包下，但注解类和使用方法是一样的，可以说完全兼容JPA标准的实体类。\r\n\r\n这里注意Getter&Setter方法的命令必须完全遵循POJO的命名规范，否则会编译不过。并建议使用驼峰命名。\r\n\r\n### 3. DAO的定义\r\n\r\n这里设计和Spring Data JPA框架一样，只要定义个 `interface` ，并继承 `YoDao` 即完成了Dao的编码工作，框架会根据这个接口的定义自动生成其实现类的代码。\r\n\r\n例如：\r\n\r\n``` Java\r\npublic interface UserDao extends YoDao<User, Long> {\r\n\r\n    User findOneByName(String name);\r\n\r\n    List<User> findListByNameAndAge(String name, int age);\r\n\r\n    List<User> findListOrderByAge();\r\n\r\n    List<User> findListOrderByAgeDesc();\r\n\r\n    long countByAge(int age);\r\n\r\n}\r\n```\r\n\r\n`YoDao<T, ID>` 的两个泛型：\r\n\r\n1. T，映射的实体类\r\n2. ID，主键PK的类\r\n\r\n\r\n\r\n### 4. 在数据库里建表\r\n\r\n框架已经将所有实体对应的table的建表SQL都生成了，只需要在建表的时候调用：\r\n\r\n``` java\r\npublic class MySQLiteOpenHelper \r\n\t\t\textends android.database.sqlite.SQLiteOpenHelper {\r\n\r\n    @Override\r\n    public void onCreate(SQLiteDatabase db) {\r\n        DaoFactory.create(HairDao.class, null).onCreateTable(db);\r\n    }\r\n\r\n    @Override\r\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\r\n        DaoFactory.create(HairDao.class, null).onUpgradeTable(db, oldVersion, newVersion);\r\n        onCreate(db);\r\n    }\r\n\r\n}\r\n```\r\n\r\n在修改实体类以后（如增加字段），只需要重新build一下，重建表的时候数据结构就会变化。\r\n\r\n\r\n\r\n### 5. 使用你的Dao\r\n\r\n``` Java\r\nUserDao userDao = DaoFactory.create(UserDao.class, mSQLiteOpenHelper);\r\n\r\n// insert\r\nUser user = new User();\r\nuser.setName(\"Jack\");\r\nuser.setAge(23);\r\nuserDao.save(user);\r\n\r\n// update\r\nuser.setName(\"New Name\");\r\nuserDao.update(user);\r\n\r\n// query\r\nList<User> users = userDao.findAll();\r\nuser = userDao.findOne(user.getId());\r\n\r\n// delete\r\nuserDao.delete(user); \r\n```\r\n\r\n\r\n\r\n## 注解说明\r\n\r\n### @Entity\r\n\r\n使用在需要映射的实体类上，框架只会处理有此注解的实体类。\r\n\r\n### @Table(name='table_ame')\r\n\r\n使用在需要映射的实体类上，属性name为表名，不提供name的时候将自动使用类名作为表名。（表名的命名规范是全部小写，下划线分割：如class名为 `UserInfo` 表名自动是 `user_info`) \r\n\r\n### @Id\r\n\r\n使用在需要映射成表主键的成员变量上，主键支持 `int` `long` `String` 类型。\r\n\r\n### @GeneratedValue\r\n\r\n使用在需要映射成主键的成员变量上，\r\n\r\n属性`strategy`为主键的生成策略：\r\n\r\n1. `AUTO` 主键自增\r\n2. `UUID` 主键使用UUID随机生成\r\n\r\n### @Column(name=\"column_ame\")\r\n\r\n使用在需要映射的成员变量上\r\n\r\n属性`name`为表列名，不提供name的时候将默认使用变量名作为列名（一样会转成全部小写，下划线分割的命名规范）\r\n\r\n属性`unique`对于SQL里面的UNIQUE\r\n\r\n属性`nullable`对应SQL里面的NOT NULL\r\n\r\n属性`length`对于SQL里面的长度限制\r\n\r\n其他属性请参考JPA。\r\n\r\n### @NotColumn\r\n\r\n使用在不需要映射的成员变量上，因为框架会将需要实体类的所有成员变量都进行映射，使用了该注解告诉框架这个字段不需要在表中持久化，则在建表时忽略该字段。\r\n\r\n### @Repository\r\n\r\n使用在自己编写的DAO上面，表示该DAO是需要框架来生成实现类的代码。\r\n\r\n### @Query\r\n\r\n使用在DAO的方法上面，表示这个方法不需要自动生成，自定义SQL查询。\r\n\r\n属性`value`为自定义查询的SQL语句。\r\n\r\n目前仅支持原生SQL，今后将支持在HSQL语法。\r\n\r\n### 其他注解\r\n\r\n今后将陆续开始支持 `OneToOne` `OneToMany` `ManyToOne` `ManyToMany` 等JPA的注解。\r\n\r\n## YoDao增删改查接口\r\n\r\n### save()\r\n\r\n``` java\r\n/**\r\n * Saves a given entity. Use the returned instance for further operations as\r\n * the save operation might have changed the entity instance completely.\r\n *\r\n * @param entity\r\n * @return the saved entity\r\n */\r\nboolean save(T entity);\r\n\r\n/**\r\n * Saves all given entities.\r\n *\r\n * @param entities\r\n * @return\r\n */\r\nboolean save(List<T> entities);\r\n```\r\n\r\n### update()\r\n\r\n``` java\r\n/**\r\n    * update a row by primary key\r\n    * \r\n    * @param entity\r\n    * @return\r\n    */\r\nint update(T entity);\r\n\r\n/**\r\n * update by fields\r\n * \r\n * @param entity\r\n * @param whereClause\r\n * @param whereArgs\r\n * @return\r\n */\r\nint updateByFields(T entity, String whereClause,\r\n           String[] whereArgs);\r\n\r\n/**\r\n * update some fields\r\n * \r\n * @param values\r\n * @param whereClause\r\n * @param whereArgs\r\n * @return\r\n */\r\nint updateByFields(ContentValues values, String whereClause,\r\n           String[] whereArgs);\r\n```\r\n\r\n### find()\r\n\r\n``` java\r\n/**\r\n * Retrives an entity by its primary key.\r\n *\r\n * @param id\r\n * @return the entity with the given primary key or {@code null} if none\r\n *         found\r\n * @throws IllegalArgumentException\r\n *             if primaryKey is {@code null}\r\n */\r\nT findOne(ID id);\r\n\r\n/**\r\n * Retrives an entity by its fields\r\n * \r\n * @param selection\r\n * @param selectionArgs\r\n * @param groupBy\r\n * @param having\r\n * @param orderBy\r\n * @return\r\n */\r\nT findOneByFields(String selection, String[] selectionArgs, String groupBy,\r\n      String having, String orderBy);\r\n\r\n/**\r\n * Retrives an entity by its fields\r\n * \r\n * @param selection\r\n * @param selectionArgs\r\n * @param orderBy\r\n * @return\r\n */\r\nT findOneByFields(String selection, String[] selectionArgs, String orderBy);\r\n\r\n/**\r\n * Retrives an entity by sql\r\n * \r\n * @param sql\r\n * @return\r\n */\r\nT findOneBySql(String sql, String[] selectionArgs);\r\n\r\n```\r\n\r\n``` java\r\n/**\r\n * Returns all instances of the type.\r\n *\r\n * @return all entities\r\n */\r\nList<T> findAll();\r\n\r\n/**\r\n * Find List By Fields\r\n * \r\n * @param selection\r\n * @param selectionArgs\r\n * @param groupBy\r\n * @param having\r\n * @param orderBy\r\n * @return\r\n */\r\nList<T> findListByFields(String selection, String[] selectionArgs,\r\n      String groupBy, String having, String orderBy);\r\n\r\n/**\r\n * Find List By Fields\r\n * \r\n * @param selection\r\n * @param selectionArgs\r\n * @param orderBy\r\n * @return\r\n */\r\nList<T> findListByFields(String selection, String[] selectionArgs,\r\n      String orderBy);\r\n\r\n/**\r\n * Find List By SQL\r\n * \r\n * @param sql\r\n * @return\r\n */\r\nList<T> findListBySql(String sql, String[] selectionArgs);\r\n```\r\n\r\n\r\n\r\n### delete()\r\n\r\n``` java\r\n/**\r\n * Deletes the entity with the given id.\r\n * \r\n * @param id\r\n */\r\nint delete(ID id);\r\n\r\n/**\r\n * Deletes a given entity.\r\n *\r\n * @param entity\r\n */\r\nint delete(T entity);\r\n\r\n/**\r\n * Deletes the given entities.\r\n *\r\n * @param entities\r\n */\r\nint delete(List<T> entities);\r\n\r\n/**\r\n * Deletes all entities managed by the repository.\r\n */\r\nint deleteAll();\r\n\r\n/**\r\n * Deletes entities by fields\r\n * \r\n * @param selection\r\n * @param selectionArgs\r\n * @return\r\n */\r\nint deleteByFields(String selection, String[] selectionArgs);\r\n```\r\n\r\n\r\n\r\n### exists()\r\n\r\n``` java\r\n/**\r\n * Returns whether an entity with the given id exists.\r\n *\r\n * @param id\r\n * @return true if an entity with the given id exists, alse otherwise\r\n * @throws IllegalArgumentException\r\n *             if primaryKey is {@code null}\r\n */\r\nboolean exists(ID id);\r\n```\r\n\r\n\r\n\r\n### count()\r\n\r\n``` java\r\n/**\r\n * Returns the number of entities available.\r\n *\r\n * @return the number of entities\r\n */\r\nlong count();\r\n\r\n/**\r\n * Returns the number of entities with selections available.\r\n * \r\n * @param selections\r\n * @param selectionArgs\r\n * @return\r\n */\r\nlong countByFields(String selections, String[] selectionArgs);\r\n```\r\n\r\n\r\n\r\n### onCreateTable()\r\n\r\n这个方法在SQLOpenHelper中的onCreate()中调用，调用后才会执行建表语句。\r\n\r\n### onUpgradeTable()\r\n\r\n这个方法在SQLOpenHelper中的onUpgrade()中调用，调用后才会执行删除表语句。\r\n\r\n\r\n\r\n## DaoFactory工厂类\r\n\r\n### 自动生成的DAO\r\n\r\n实现类\r\n\r\n默认情况下，框架会根据你写的dao的包名和类名来生成实现类的包名和类名。\r\n\r\n例如，你的Dao为：\r\n\r\n``` java\r\ncom.your.test.dao.UserDao\r\n```\r\n\r\n那么生成的实现类名为：\r\n\r\n``` java\r\ncom.your.test.dao.impl.UserDaoImpl\r\n```\r\n\r\n在android studio里，自动的生成的代码在项目根目录下的`build/source/apt/debug`目录里 ，这个目录由插件决定，eclipse上可以自行配置。\r\n\r\n### 实例化DAO\r\n\r\n框架推荐不直接调用和实例化自动生成的Impl类，而应该使用 `DaoFactory` 来实例化Dao，例如：\r\n\r\n``` java\r\nUserDao userDao = DaoFactory.create(UserDao.class, mSQLiteOpenHelper);\r\n```\r\n\r\n今后将支持通过注解来定义生命周期以支持对于指定Dao可选性的单例模式。目前所有Dao都默认非单例。\r\n\r\n\r\n\r\n## DAO的写法\r\n\r\n### 自定义Dao\r\n\r\n一般情况下，自定义的 `dao` 只需要写一个空的　`interface` 然后继承 `YoDao`接口即够用了，因为接口里实现了大量增删改查的API。\r\n\r\n例如：\r\n\r\n``` java\r\npublic interface UserDao extends YoDao<User, Long> {\r\n\r\n}\r\n```\r\n\r\n注意：两个泛型不要搞反了，第一个是实体类，第二个是主键。今后框架将会校验，目前还没有。\r\n\r\n### 方法的定义\r\n\r\n对于接口无法满足的时候，则可以通过定义接口的方法来实现，这里必须按照指定的约定来写方法名，框架则会按照方法的定义来帮你实现。\r\n\r\n> 如果你写的方法名不被支持，则框架在编译时会提示哪一个方法定义出现了问题，请查询相关文档来修改方法的定义。\r\n\r\n以下列出所有支持的方法：\r\n\r\n#### WHERE\r\n\r\n``` java\r\nUser findOneByName(String name);\r\n// SQL: select * from user where name = ? limit 1\r\n\r\n// AND\r\nList<User> findListByNameAndAge(String name, int age);\r\n// SQL: select * from user where name = ? and age = ?\r\n\r\n// OR\r\nList<User> findListByNameOrAge(String name, int age);\r\n// SQL: select * from user where name ? or age = ?\r\n```\r\n\r\n#### GROUP BY\r\n\r\n``` java\r\nList<User> findListByNameGroupByAge(String name);\r\n// SQL: select * from user where name = ? group by age;\r\n\r\n// HAVINGS\r\n// 暂不支持\r\n```\r\n\r\n#### ORDER BY\r\n\r\n``` java\r\nList<User> findListOrderByAge();\r\n// SQL: select * from user order by age\r\n\r\nList<User> findListOrderByAgeDesc();\r\n// SQL: select * from user order by age DESC\r\n```\r\n\r\n#### UPDATE\r\n\r\n``` java\r\nint updateByName(User user, String name);\r\n// SQL: update user ... where name = ?\r\n```\r\n\r\n#### DELETE\r\n\r\n``` java\r\nint deleteByName(String name);\r\n// SQL: delete from user where name = ?\r\n```\r\n\r\n#### COUNT\r\n\r\n``` java\r\nlong countByAge(int age);\r\n```\r\n\r\n#### 原生SQL\r\n\r\n``` java\r\n@Query(value= \"select * from user where name = ?\")\r\nUser findByUsername(String username);\r\n```\r\n\r\n\r\n\r\n#### 关键要点：\r\n\r\n1. 所有SQL的关键字都有意义，不能随便将其放置在方法名中，如 `BY` `Order` `Where` 等。\r\n2. 注意字段名的命名规范，这里会将字段名转成和字段名一样的命名规范，即全部小写，下划线分词，例如　`findByUserName` 那么则直接使用 `where user_name = ?`的SQL来查找，并且会使用 `setUserName()` 和　`getUserName()` 方法来设值和取值。Java的字段名和方法名都保持驼峰命名法，数据库的表名和列名都按全部小写，下划线分割的命名法。\r\n\r\n#### 方法的参数\r\n\r\n方法的参数的个数和顺序必须和方法定义的查询保持一致。\r\n\r\n#### 方法的返回值\r\n\r\n方法的返回值类型只能是：　\r\n\r\n1. `T`  find语句\r\n2. `List<T>`　find语句\r\n3. `boolean`　exists语句\r\n4. `long`　count语句\r\n5. `int`　delete语句\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}